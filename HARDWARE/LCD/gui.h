#ifndef __GUI_H
#define __GUI_H 


typedef struct 
{
       unsigned char Index[2];	
       char Msk[128];
}typFNT_GB32; 



const typFNT_GB32 tfont32[]=
{
"字",0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0xC0,0x00,
0x00,0x01,0xC0,0xC0,0x00,0x01,0x07,0xC0,0x00,0x01,0xFF,0x00,0x02,0x1F,0xFE,0x00,
0x07,0xF0,0x1C,0x00,0x07,0xC0,0x70,0x00,0x0F,0x00,0xE0,0x00,0x0E,0x03,0xF0,0x00,
0x1C,0x0F,0xF0,0x00,0x3C,0x0F,0x70,0x00,0x3C,0x00,0xE0,0x00,0x18,0x00,0xC0,0x00,
0x00,0x00,0xC0,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x20,0x00,
0x00,0x00,0x37,0x00,0x00,0x01,0xFF,0x00,0x00,0x7F,0xF8,0x00,0x07,0xF8,0x30,0x00,
0x1F,0x80,0x30,0x00,0x00,0x80,0x30,0x00,0x00,0xC0,0x30,0x00,0x00,0x60,0x60,0x00,
0x00,0x18,0xE0,0x00,0x00,0x0F,0xC0,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,

};

typedef struct 
{
       unsigned char Index[2];	
       char Msk[32];
}typFNT_GB16; 

const typFNT_GB16 tfont16[]=
{
"按",0x10,0x40,0x10,0x20,0x10,0x20,0x13,0xFE,0xFA,0x02,0x14,0x44,0x10,0x40,0x1B,0xFE,
0x30,0x88,0xD0,0x88,0x11,0x08,0x10,0xD0,0x10,0x20,0x10,0x50,0x50,0x88,0x23,0x04,/*"?",0*/
"键",0x20,0x10,0x20,0x10,0x3B,0x7C,0x21,0x14,0x41,0xFE,0x7A,0x14,0xA2,0x7C,0x27,0x10,
0xF9,0x7C,0x25,0x10,0x25,0xFE,0x22,0x10,0x2A,0x10,0x35,0x00,0x28,0xFE,0x00,0x00,/*"?",1*/
"一",0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFE,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"?",2*/
	
"上",0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x03,0xF8,0x02,0x00,
0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0xFF,0xFE,0x00,0x00,/*"?",0*/
"身",0x02,0x00,0x04,0x00,0x1F,0xF0,0x10,0x10,0x1F,0xF0,0x10,0x10,0x1F,0xF2,0x10,0x14,
0x10,0x18,0x7F,0xF0,0x00,0x50,0x00,0x90,0x03,0x10,0x1C,0x10,0xE0,0x50,0x00,0x20,/*"?",1*/
	

"综",0x00,0x00,0x00,0x00,0x10,0x20,0x11,0xFE,0x22,0x02,0x22,0x02,0x49,0xFC,0x58,0x00,
0x30,0x00,0x13,0xFE,0x25,0x28,0x79,0x24,0x01,0x24,0x0D,0x24,0x72,0x22,0x02,0xA2,/*4*/
"合",0x00,0x00,0x00,0x00,0x01,0x80,0x02,0x40,0x04,0x30,0x18,0x08,0x60,0x06,0x1F,0xF8,
0x00,0x00,0x1F,0xF8,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x1F,0xF8,/*5*/


"测",0x00,0x00,0x00,0x00,0x67,0xC2,0x14,0x52,0x05,0x52,0x05,0x52,0xC5,0x52,0x25,0x52,
0x05,0x52,0x05,0x52,0x15,0x52,0x17,0x52,0x22,0x82,0x22,0x42,0x44,0x42,0x48,0x3E,/*2*/
"试",0x00,0x00,0x00,0x00,0x20,0x14,0x10,0x14,0x17,0xFE,0x00,0x12,0x00,0x10,0x60,0x10,
0x13,0xF0,0x10,0x90,0x10,0x90,0x10,0x90,0x14,0x92,0x14,0xEA,0x1F,0x0A,0x00,0x06,/*3*/
"程",0x00,0x00,0x00,0x00,0x19,0xFE,0x72,0x02,0x12,0x02,0x12,0x02,0x7D,0xFC,0x18,0x00,
0x1B,0xFE,0x34,0x20,0x50,0x20,0x53,0xFE,0x10,0x20,0x10,0x20,0x10,0x20,0x13,0xFE,/*8*/
"序",0x00,0x00,0x00,0x00,0x00,0x80,0x3F,0xFE,0x40,0x00,0x47,0xFC,0x42,0x08,0x41,0x30,
0x40,0xC0,0x5F,0xFE,0x40,0x42,0x40,0x42,0x40,0x44,0x40,0x48,0x40,0x40,0x44,0x40,/*9*/

};
typedef struct 
{
       unsigned char Index[2];	
       char Msk[72];
}typFNT_GB24; 
const typFNT_GB24 tfont24[]=
{
"测",0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x03,0x21,
0xFF,0x33,0x39,0x83,0x33,0x11,0x83,0x33,0x01,0x9B,0x33,0xC1,0x9B,0x33,0x71,0x9B,
0x33,0x19,0x9B,0x33,0x01,0x9B,0x33,0x01,0x9B,0x33,0x11,0x9B,0x33,0x19,0xB3,0x33,
0x30,0x30,0x33,0x30,0x6C,0x03,0x30,0xC6,0x03,0x63,0x83,0x03,0x2E,0x01,0xBE,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*2*/
"试",0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0xD8,0x30,
0x00,0xCE,0x18,0x00,0xC2,0x1C,0x00,0xC0,0x01,0xFF,0xFF,0x00,0x00,0xC0,0xF8,0x00,
0xC0,0x18,0x00,0xC0,0x19,0xFF,0xC0,0x18,0x18,0x40,0x18,0x18,0x60,0x19,0x18,0x60,
0x1B,0x18,0x61,0x1E,0x18,0x31,0x1C,0x1F,0xB1,0x39,0xF0,0x19,0x10,0x00,0x0F,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*3*/
};  

void GUI_DrawFont16(u16 x, u16 y, u16 fc, u16 bc, u8 *s,u8 mode)
{
	u8 i,j;
	u16 k;
	u16 HZnum;
	u16 x0=x;
	HZnum=sizeof(tfont16)/sizeof(typFNT_GB16);	//自动统计汉字数目		
	for (k=0;k<HZnum;k++) 
	{
	  if ((tfont16[k].Index[0]==*(s))&&(tfont16[k].Index[1]==*(s+1)))
	  { 	LCD_SetWindows(x,y,x+16-1,y+16-1);
		    for(i=0;i<16*2;i++)
		    {
				for(j=0;j<8;j++)
		    	{	
					if(!mode) //非叠加方式
					{
						if(tfont16[k].Msk[i]&(0x80>>j))	LCD_DrawPoint_16Bit(fc);
						else LCD_DrawPoint_16Bit(bc);
					}
					else
					{
						POINT_COLOR=fc;
						if(tfont16[k].Msk[i]&(0x80>>j))	LCD_DrawPoint(x,y);//画一个点
						x++;
						if((x-x0)==16)
						{
							x=x0;
							y++;
							break;
						}
					}

				}
				
			}
			
			
		}				  	
		continue;  //查找到对应点阵字库立即退出，防止多个汉字重复取模带来影响
	}

	LCD_SetWindows(0,0,lcddev.width-1,lcddev.height-1);//恢复窗口为全屏  
} 

void GUI_DrawFont24(u16 x, u16 y, u16 fc, u16 bc, u8 *s,u8 mode)
{
	u8 i,j;
	u16 k;
	u16 HZnum;
	u16 x0=x;
	HZnum=sizeof(tfont24)/sizeof(typFNT_GB24);	//自动统计汉字数目
		
			for (k=0;k<HZnum;k++) 
			{
			  if ((tfont24[k].Index[0]==*(s))&&(tfont24[k].Index[1]==*(s+1)))
			  { 	LCD_SetWindows(x,y,x+24-1,y+24-1);
				    for(i=0;i<24*3;i++)
				    {
							for(j=0;j<8;j++)
							{
								if(!mode) //非叠加方式
								{
									if(tfont24[k].Msk[i]&(0x80>>j))	LCD_DrawPoint_16Bit(fc);
									else LCD_DrawPoint_16Bit(bc);
								}
							else
							{
								POINT_COLOR=fc;
								if(tfont24[k].Msk[i]&(0x80>>j))	LCD_DrawPoint(x,y);//画一个点
								x++;
								if((x-x0)==24)
								{
									x=x0;
									y++;
									break;
								}
							}
						}
					}
					
					
				}				  	
				continue;  //查找到对应点阵字库立即退出，防止多个汉字重复取模带来影响
			}

	LCD_SetWindows(0,0,lcddev.width-1,lcddev.height-1);//恢复窗口为全屏  
}


void GUI_DrawFont32(u16 x, u16 y, u16 fc, u16 bc, u8 *s,u8 mode)
{
	u8 i,j;
	u16 k;
	u16 HZnum;
	u16 x0=x;
	HZnum=sizeof(tfont32)/sizeof(typFNT_GB32);	//自动统计汉字数目
	for (k=0;k<HZnum;k++) 
			{
			  if ((tfont32[k].Index[0]==*(s))&&(tfont32[k].Index[1]==*(s+1)))
			  { 	
					LCD_SetWindows(x,y,x+32-1,y+32-1);
				  for(i=0;i<32*4;i++)
				  {
						for(j=0;j<8;j++)
				    {
							if(!mode) //非叠加方式
							{
								 if(tfont32[k].Msk[i]&(0x80>>j))
								 LCD_DrawPoint_16Bit(fc);
								else
									LCD_DrawPoint_16Bit(bc);
							}
							else
							{
								POINT_COLOR=fc;
								if(tfont32[k].Msk[i]&(0x80>>j))	
									LCD_DrawPoint(x,y);//画一个点
								  x++;
								if((x-x0)==32)
								{
									x=x0;
									y++;
									break;
								}
							}
						}
					}
					
					
				 }				  	
				continue;  //查找到对应点阵字库立即退出，防止多个汉字重复取模带来影响
			}
	
	LCD_SetWindows(0,0,lcddev.width-1,lcddev.height-1);//恢复窗口为全屏  
} 

void Show_Str(u16 x,u16 y,u16 fc,u16 bc,u8 *str,u8 size,u8 mode)
{					
	  u16 x0=x;							  	  
  	u8 bHz=0;     //字符或者中文 
    while(*str!=0)//数据未结束
    { 
        if(!bHz)
        {
			if(x>(lcddev.width-size/2)||y>(lcddev.height-size)) 
			return; 
	        if(*str>0x80)bHz=1;//中文 
	        else              //字符
	        {          
		        if(*str==0x0D)//换行符号
		        {         
		            y+=size;
					x=x0;
		            str++; 
		        }  
		        else
				{
					if(size>16)//字库中没有集成12X24 16X32的英文字体,用8X16代替
					{  
					LCD_ShowCharone(x,y,fc,bc,*str,16,mode);
					x+=8; //字符,为全字的一半 
					}
					else
					{
					LCD_ShowCharone(x,y,fc,bc,*str,size,mode);
					x+=size/2; //字符,为全字的一半 
					}
				} 
				str++; 
		        
	        }
        }else//中文 
        {   
			if(x>(lcddev.width-size)||y>(lcddev.height-size)) 
			return;  
            bHz=0;//有汉字库    
			if(size==32)
			GUI_DrawFont32(x,y,fc,bc,str,mode);	 	
			else if(size==24)
			GUI_DrawFont24(x,y,fc,bc,str,mode);	
			else
			GUI_DrawFont16(x,y,fc,bc,str,mode);
				
	        str+=2; 
	        x+=size;//下一个汉字偏移	    
        }						 
    }   
}

#endif


